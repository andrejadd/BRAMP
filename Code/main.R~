####
####
####
#### main function

main <- function(X, Y, initiation, GLOBvar, HYPERvar){
  
  ### assignement of global variables used here ###
  niter = GLOBvar$niter
  smax = GLOBvar$smax
  q = GLOBvar$q
  birth_proposals = GLOBvar$birth_proposals
  ### end assignement ###

  ### assignement of hyperparameters variables used here ###
  cD = HYPERvar$cD
  alphaD = HYPERvar$alphaD
  betaD = HYPERvar$betaD
  ### end assignement ###
  
  ### assignement of initiation variables used here ###
  # initial state
  XE = initiation$initState$XE
  YE = initiation$initState$YE
  S2Dall = initiation$initState$S2Dall
  B2Dall = initiation$initState$B2Dall
  Sig2_2Dall = initiation$initState$Sig2_2Dall

#  HYPERvar$delta2 = 0.1
  
  k_x = length(XE) - 2
  k_y = length(YE) - 2

  
  
  ## counting CP moves (CP Birth, CP death, CP move, Updating phases)
  cptMove2 = array(0,4)
  acceptMove2 = array(0,4)

  ## counting "Updating phases" moves (Edge Birth, Edge death, Udating regression coefficient)
  cptMove = array(0,3)
  acceptMove = array(0,3)
  
## AA DATA DEFINITIONS, THESE ARE SAVED AT THE END OF THIS FUNCTION

  Structsamples = list(struct = list(), cps = list(), iter=list())
  counters = list()

  # do main iteration
  r = 1
  while(r < niter) {

    r = r + 1

    ## decide by same chance which axis to alter: x or y 
    ALTERX = T
    k = length(XE) - 2  # need this for next rgamma calculation
    
    if(runif(1,0,1) < 0.5) {
      ALTERX = F
      k = length(YE) - 2
    }
    
    ## mean nr. of changepoints (lambda)    
    D = rgamma(1, shape= k + alphaD, rate = 1+betaD)

## DEBUG START
     out = phase.update(XE, YE, S2Dall, B2Dall, Sig2_2Dall, X, Y, GLOBvar, HYPERvar, F, F)
 
#    out = cp.shift(ALTERX, XE, YE, S2Dall, B2Dall, Sig2_2Dall, X, Y, GLOBvar, HYPERvar, T,T)
#    out = cp.death(ALTERX, XE, YE, S2Dall, B2Dall, Sig2_2Dall, X, Y, D, GLOBvar, HYPERvar, T,T)
#    out = cp.birth(ALTERX, XE, YE, S2Dall, B2Dall, Sig2_2Dall, X, Y, D, GLOBvar, HYPERvar, T,T)

    ## Apply changes to the current model
    XE = out$XE
    YE = out$YE
    B2Dall = out$B2Dall
    S2Dall = out$S2Dall
    Sig2_2Dall = out$Sig2_2Dall
    cptMove2[out$move] = cptMove2[out$move]+1
    acceptMove2[out$move] = acceptMove2[out$move]+out$accept

    
    ######
    ##
    cat("fixme: calculate global delta2 in main.R! need to calculate at every iteration?")
    
    next
    
## DEBUG END

    # AA : ATTENTION, s is used here update!!
    rho = computeRho4(s, 0, smax, cD, D)
 
    ## Sample u to choose one of the 4 moves : CP birth, CP death, CP shift, Update phases.
    u1 = runif(1, 0, 1)
    
    ## Run 1 out of the 4 moves (depending on the value of u)
    if (u1 < rho[1]){
      ## CP birth move: return the new model if the move is accepted, the previous model otherwise.
      out = cp.birth(ALTERX, XE, YE, S2Dall, B2Dall, Sig2_2Dall, X, Y, D, GLOBvar, HYPERvar, T,F)
  
    } else {
      if(u1 < rho[2]){
     
        ## CP death move: return the new model if the move is accepted, the previous model otherwise.
           out = cp.death(ALTERX, XE, YE, S2Dall, B2Dall, Sig2_2Dall, X, Y, D, GLOBvar, HYPERvar, T,F)
      	
      } else {
        if(u1 < rho[3]){

          ## CP shift move: return the new model if the move is accepted, the previous model otherwise.
          out =  cp.shift(ALTERX, XE, YE, S2Dall, B2Dall, Sig2_2Dall, X, Y, GLOBvar, HYPERvar, F,F)


        } else {
          ## Update phases: return the new model if the move is accepted, the previous model otherwise.
          out = phase.update(Segments, S2Dall, B2Dall, Sig2_2Dall, X, Y, GLOBvar, HYPERvar, F, F)
          
          cptMove[out$move1] = cptMove[out$move1]+1
          acceptMove[out$move1] = acceptMove[out$move1]+out$accept1

        }
      }
    }

  ## Apply changes to the current model

    B2Dall = out$B2Dall
    S2Dall = out$S2Dall
    Sig2_2Dall = out$Sig2_2Dall
    cptMove2[out$move] = cptMove2[out$move]+1
    acceptMove2[out$move] = acceptMove2[out$move]+out$accept
    

  
## AA GET DATA
    # every X iteration (to save memory)
    if((r %% 10) == 0) {

      # save data, this is written to the major outfile        
      Structsamples$struct[[length(Structsamples$struct) + 1]] = S2Dall
      Structsamples$cps[[length(Structsamples$cps) + 1]] = Segments
      Structsamples$iter[[length(Structsamples$iter) + 1]] = r
      counters[[length(counters) + 1]] = list(cptMove2=cptMove2, acceptMove2=acceptMove2, cptMove=cptMove, acceptMove=acceptMove)
 
    }

    #  print status every X and save data to disk iteration 
    if((r %% 2000) == 0) {
       cat("\nr: ", r, "\t")

       cat("mem(Structsamples): ", object.size(Structsamples)/1048600, "\n")
       writeDataOut(GLOBvar, Structsamples, counters)

       
     }
    
       #lastedges = array()
       #for(e in 1:dim(Sall)[1]) {
        
       #  pos = which(Sall[e,1:q] == 1)

       #  for(pp in 1:length(pos)) { cat(pos[pp], " ") }
         
       #  cat(" | ")
         
                                        # first
       #  if(e == 1) {
       #    lastedges = pos
       #  } else {
       #    if(length(intersect(lastedges, pos)) != length(pos)) {
             
       #      cat("-> different phases found in Sall:\n")
             
       #    }
       #  }
         
       #}
       
       #cat("\n")

#       structoutfile = paste("./Results/Network_And_CPs/Structsamples_n", GLOBvar$networkid, "_i", GLOBvar$target, "_run", GLOBvar$runid, sep="")
#       cat("[SAVE] attempting to write Structsamples to: ", structoutfile, "\n\n")

#       predictorSet = GLOBvar$posTF # copy out in order to write
#       save(Structsamples, counters, predictorSet, file = structoutfile)
              
#     }
    
    
  } # end iteration

  writeDataOut(GLOBvar, Structsamples, counters)
  
 
  return(1)
}

