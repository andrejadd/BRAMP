###############################################
###        tvDBN  :  initialisation        ####
###############################################


#####################################################################
# depends on : 




## Sample k from a truncated Poisson distribution, (eq 4.5)
sampleK <- function(mini, maxi, lambda, nb){
  # AA: mini: minimal nr. of endges (set to 0)
  #     maxi: max nr. edges (=qmax)
  #     lambda: nr. of expected edges
  #     nb: 1
  # it basically says, sample the probability of each k in [mini..maxi] following a poission distribution with given lambda
  # this is the part with prob, then select one k in [mini..maxi] dependent on the probability
  if( mini == maxi) { print("Error with sampling from a truncated Poisson: mini = maxi") }
  out = sample( mini:maxi, nb, replace=TRUE, prob=lambda^(mini:maxi)/apply(matrix(mini:maxi, 1, maxi-mini+1), 2, factorial))
  return(out)
  
}

##############################################
## Sample initial regression coefficient B 

sampleBinit <- function(Si, sig2, delta2, X, q){
  ### INPUT: s=S[i,],sig2=Sig2[i],delta2,
  ###        X the observed data for predictors.
  ###        q number of predictors
  ### OUTPUT: vector newB.
  ### depends on: q the number of predictors.
  newB <- array(0,q+1)
  
  for(l in which(Si == 1)){
    newB[l] <- rnorm(1, mean=0, sd=sqrt(delta2 * sig2 * t(X[,l]) %*% X[,l]))
  }
  return(newB)
}


##############################################
## Sample parameters

sampleParms <- function(X, GLOBvar, HYPERvar, s=NULL, CPinit=NULL){
  ### assignement of global variables used here ###
  smax = GLOBvar$smax
  q = GLOBvar$q
  qmax = GLOBvar$qmax
  n = GLOBvar$n
  Mphase = GLOBvar$Mphase
  nbVarMax = GLOBvar$nbVarMax
  dyn = GLOBvar$dyn
  minPhase = GLOBvar$minPhase
  ### end assignement ###
  ###  !!! dyn=1 for dynamic modelling !!!
  ###  !!! dyn=0 for static modelling !!!
  
  ### assignement of hyperparameters variables used here ###
  alphaD = HYPERvar$alphaD
  betaD = HYPERvar$betaD
  alphalbd = HYPERvar$alphalbd
  betalbd = HYPERvar$betalbd
  v0 = HYPERvar$v0
  gamma0 = HYPERvar$gamma0
  alphad2 = HYPERvar$alphad2
  betad2 = HYPERvar$betad2
  ### end assignement ###

  ## Sample the number of breakpoint positions  
  if(!(is.null(CPinit))){
	E=CPinit
	s=length(E)-2
  }else{
	if( is.null(s) ){
		## If s=NULL, sample s.
		## sample D for the number of CP :
		D = rgamma(1, shape=alphaD, rate = betaD)  # scale s= 1/rate => f(x)= 1/(s^a Gamma(a)) x^(a-1) e^-(x/s)
    
		## Sample s
		s <- sampleK(0,smax,D,1)
	} else {
		## Update D 
		D = rgamma(1, shape=alphaD+s, rate = betaD+1)
	}

	## CP (phase > 2)
	E = c(1+dyn, n+1)
	cpt = s
	while(cpt > 0){
		# search for possible CP, not in E and not close to E if minPhase (length of phase) is > than 1
		toremove = E
		if(minPhase>1) for(i in 1:(minPhase-1)) toremove = c(toremove, E-i, E+i)
		# possibles CPs are those not in 'toremove'
		possibleCP = setdiff((1+dyn):E[length(E)], toremove)
		# sample one CP in possibleCP (the vector is double for sake of function sample when size is = to 1)
		cp = sample( c(possibleCP, possibleCP), 1)
    
		E=sort(c(E, cp))
		cpt = cpt-1
	}
  }

  ###  sample model for each hidden state
  ## sample model structure
  S = matrix(0, s+1, q+1)
  for (i in 1:(s+1)){
    ## sample lambda
    lambda = rgamma(1, shape=alphalbd, rate = betalbd)  # scale s= 1/rate => f(x)= 1/(s^a Gamma(a)) x^(a-1) e^-(x/s)
    
    ## sample the nb of predictors
    ## kPred=0 # modif 16 avril 08
    kPred = sampleK(0, qmax, lambda, 1)

    if(kPred>0){
      S[i, sample(1:q, kPred, replace=FALSE)] = array(1, kPred) # structure du model (1 si pred in the model)
    }
  }
  ## we assume that there is a constante in each model
  S[, q+1] = array(1,s+1)

  ## sample sigma : IG(v0/2,gamma0/2)
  Sig2 = rinvgamma(n=min(nbVarMax,s+1), shape=v0/2, scale=gamma0/2)

  ## Coefficients 
  B = matrix(0,s+1,q+1)

  ## sample coef 
  for (i in 1:(s+1)){
    if(nbVarMax == 1){ iSig = 1 } else { iSig = i }
    ## sample delta2
    delta2 = rinvgamma(1, shape=alphad2, scale=betad2)
    B[i,] = sampleBinit(S[i,], Sig2[iSig], delta2, X[(Mphase[E[i]]):(Mphase[E[i+1]]-1),], q)
  }
  return(list(E=E, S=S, B=B, Sig2=Sig2, s=s))
}



sampleBxy <- function(xi, y, Sig2, delta2){
  # INPUT: xi, yi, sig2i, delta2
  # OUTPUT: B
  # depends on: .
  Ml = (delta2 / (delta2+1)) * pseudoinverse(t(xi) %*% xi)
  out = mvrnorm(1, mu=Ml %*% t(xi) %*% y, Sigma=Sig2*Ml)
  return(out)
}


sampleDelta2 <- function(pos, x, q, B, S, sig2, alphad2, betad2){
  # INPUT: pos, the considered state
  #        xPos, the observations of X in state i
  #        B,S,Sig2
  #        alphad2,betad2.
  # OUTPUT: delta2
  # depends on: . 
  plus = 0
  if(sum(S[pos,])>0){
    Bi = B[pos, which(S[pos,] == 1)]
    xi = x[, which(S[pos,] == 1)]
    plus = Bi %*% t(xi) %*% xi %*% Bi / (2* sig2)
  }
  out = rinvgamma(1, shape=sum(S[pos,1:q]) + alphad2, scale=betad2 + plus)
  return(out)
}


updateSigMulti <- function(phase, X, Y, E, Sall, Ball, Sig2, Mphase, alphad2, betad2, v0, gamma0){
  
  posPhase = which(E == phase)
  S = Sall[posPhase,]
  k = sum(Sall[posPhase,])-1
  #new definition of Mphase: -dyn not required!
  y = Y[(Mphase[phase]:(Mphase[E[posPhase+1]]-1))]
  x = X[(Mphase[phase]:(Mphase[E[posPhase+1]]-1)),]
  delta2 = rinvgamma(1, shape=k + alphad2, scale=betad2 + Ball[posPhase, which(S == 1)] %*% t(x[, which(S == 1)]) %*% x[,which(S == 1)] %*% Ball[posPhase,which(S == 1)] / (2 * Sig2) )
  matPx = computePx(length(y), x[, which(S == 1)], delta2)
    
  total = t(y) %*% matPx %*%y
  out = rinvgamma(1, shape=v0/2 + length(y)/2, scale=(gamma0 + total)/2)
  return(out )
  
}

sampleSig2 <- function(y, Px, v0, gamma0) {
  out = rinvgamma(1, shape=v0/2 + length(y)/2, scale = (gamma0 + t(y) %*% Px %*% y)/2)
  return(out)
}

updateSigSolo <- function(X, Y, E, Sall, Ball, Sig2, Mphase, alphad2, betad2, v0, gamma0){
 
  total = 0
  for (phase in E[1:(length(E)-1)]){
    posPhase = which(E == phase)
    S = Sall[posPhase,]
    k = sum(Sall[posPhase,])-1
    #new definition of Mphase: -dyn not required!
    y = Y[(Mphase[phase]:(Mphase[E[posPhase+1]]-1))]
    x = X[(Mphase[phase]:(Mphase[E[posPhase+1]]-1)),]
    delta2 = rinvgamma(1, shape=k + alphad2, scale=betad2 + Ball[posPhase, which(S == 1)] %*% t(x[, which(S == 1)]) %*% x[, which(S == 1)] %*% Ball[posPhase, which(S == 1)] / (2 * Sig2) )
    matPx = computePx(length(y), x[,which(S == 1)], delta2)
    total = total + t(y) %*% matPx %*%y
  }
  
  newSig2=rinvgamma(1, shape=v0/2+length(y)/2, scale = (gamma0+total)/2)
  ## newSig2=rinvgamma(1, shape=v0/2+length(y)/(length(E)-1)/2, scale = (gamma0+total)/(length(E)-1)/2)
  ## newSig2=rinvgamma(1, shape=v0/2+length(y)/2, scale = (gamma0+total/(length(E)-1))/2)
  ## newSig2=rinvgamma(1, shape=v0/2+ mean(E[2:length(E)]-E[1:(length(E)-1)])*m/2, scale = (gamma0+total/(length(E)-1))/2)

  ## mean( rinvgamma(100, shape=v0/2+length(y)/2, scale = (gamma0+total)/2))
  ## var( rinvgamma(100, shape=v0/2+length(y)/2, scale = (gamma0+total)/2))
  ## plot.density(density(rinvgamma(100, shape=v0/2, scale = gamma0/2)))          
  ## mean( rinvgamma(100, shape=v0/2+length(y)/2, scale = (gamma0+total/(length(E)-1))/2))
  ## var( rinvgamma(100, shape=v0/2+length(y)/2, scale = (gamma0+total/(length(E)-1))/2))
  
  return(newSig2)
}


updateSig <- function(u, rho, X, Y, Sall, Ball, Sig2all){
  ################ ATTENTION ##################
  ## VARIABLES GLOBALES : target, n, Mphase, alphad2, betad2, v0, gamma0
  
  newSig2 = Sig2all
  #for (target in 1:p){
  vect = ((target-1) * n+1):(target * n)
  total = 0 
  for (phase in Eall[which(Eall %in% vect)]) {
    posPhase = which(Eall == phase)
    S = Sall[posPhase,]
    k = sum(Sall[posPhase,])-1
    y = Y[Mphase[phase]:(Mphase[Eall[posPhase+1]]-1)]
    x = X[Mphase[phase]:(Mphase[Eall[posPhase+1]]-1),]
    delta2 = rinvgamma(1, shape=k + alphad2, scale=betad2 + Ball[posPhase, which(S==1)] %*% t(x[, which(S == 1)]) %*% x[,which(S == 1)] %*% Ball[posPhase,which(S == 1)] / (2 * Sig2all[target]))
    matPx = computePx(length(y), x[,which(S == 1)], delta2)
    
    total = total + t(y) %*% matPx %*% y
  }
  newSig2[target] = rinvgamma(1, shape=v0/2 + length(y)/2, scale=(gamma0 + total / sum(Eall %in% vect))/2)
#}
#
  return(newSig2)
}
