#initialisation
init <- function(X, Y, sinit, GLOBvar, HYPERvar, CPinit=NULL){
  ### assignement of global variables used here ###
  niter = GLOBvar$niter
  smax = GLOBvar$smax
  p = GLOBvar$p
  q = GLOBvar$q
  ### end assignement ###
  
  
  # stock along iteration
  # for stocking E (vector of CPs)
  Estock = matrix(0, niter, smax+p+1)

  # for stocking S (vector of network models -models coded in power2- for each possible phase (smax+1 phase possible))
  Sstock = matrix(-1, niter, smax+1)

  # for stocking B (vector of predictor coefficients + constant (q+1) for each phase (smax+1))
  # AATOOBIG: Bstock = matrix(0, niter, (q+1)*(smax+p))

  # for stocking sigma (vector of sigma noise at each phase (smax+1))
  # AATOOBIG: Sig2stock = matrix(0, niter, smax+p) 
  
  ## counting CP moves (CP Birth, CP death, CP move, Updating phases)
  cptMove2 = array(0,4)
  acceptMove2 = array(0,4)

  ## counting "Updating phases" moves (Edge Birth, Edge death, Udating regression coefficient)
  cptMove = array(0,3)
  acceptMove = array(0,3)

  counters = list(cptMove2=cptMove2, acceptMove2=acceptMove2, cptMove=cptMove, acceptMove=acceptMove)
  
  ## Initialisation
  init = sampleParms(X, GLOBvar, HYPERvar, s=sinit, CPinit) 

  ## Nb of changepoints (is length(E) - 2)
  s = init$s

  ## Vector of changepoints location
  E = init$E

  ## Boolean matrix (nb of phases x (q+1)) describing set of predictors of each phase
  Sall = init$S

  ## Real matrix (nb of phases x (q+1)) describing regression coefficients of each phase
  Ball = init$B

  ## Variance
  Sig2all = init$Sig2

  # creates first iteration values
  initState = list(s=s, E=E, Sall=Sall, Ball=Ball, Sig2all=Sig2all)
  
  ## Stock first iteration
  Estock[1,1:(s+2)] = init$E

  # "%*%" is the matrix product, binary
  # power of two coding: e.g. 2^(1:3) gives a list: 2 4 8
  # left and right side of %*% are lists of same size (q)
  # return one number, the binary (base 2) encoded binary string, e.g.
  # (1 0 1) %*% 2^(0:2) = 1*2 + 0*4 + 1*4 = 5
  Sstock[1,1:(s+1)] = init$S[,1:q] %*% 2^(0:(q-1))

  
# AATOOBIG:  Bstock[1,1:((s+1)*(q+1))] = t(init$B)	
# AATOOBIG:  Sig2stock[1,1:length(init$Sig2)] = init$Sig2
# AATOOBIG:  listStock = list(Estock=Estock, Sstock=Sstock, Bstock=Bstock, Sig2stock=Sig2stock)

  listStock = list(Estock=Estock, Sstock=Sstock)

   # AABIG: only do it for birth_proposal 4, since this gets also too large and we do not need it (birth_proposal 2) 
  post_probs = 0
  if(GLOBvar$birth_proposal == 4) {
    post_probs = calculatePostProbs(X, Y, sinit, GLOBvar, HYPERvar);
  }
  
  return(list(counters=counters, initState=initState, listStock=listStock, 
    post_probs = post_probs))
}


calculatePostProbs <- function(X, Y, l, GLOBvar, HYPERvar){
	
  q = GLOBvar$q
  lmax = GLOBvar$lmax
	
### assignement of hyperparameters variables used here ###
  alphad2 = HYPERvar$alphad2
  betad2 = HYPERvar$betad2
  alphaD = HYPERvar$alphaD
  betaD = HYPERvar$betaD
### end assignement ###
  v0 = HYPERvar$v0

  # gamma distribution, shape and rate (inverse of scale)
  D = rgamma(1, shape=alphaD, rate = betaD)

  # inverse gamma distribution (custom: see invGamma.R)
  delta2 = rinvgamma(1, shape=alphad2, scale=betad2) 
  
  parent_list = matrix(0, 1, lmax);

  # the parent list, where ist it used?
  for (parent_no in 1:lmax) {

    combs = t(combn(1:q, parent_no));
    new_parent_list = matrix(0, dim(combs)[1], lmax);
    
    new_parent_list[,(lmax-parent_no+1):lmax] = combs;
    
    parent_list = rbind(parent_list, new_parent_list);
  }
  
  confs = dim(parent_list)[1];
  
  cumul = matrix(0, confs, lmax + 1)
  probs = list();
  
  for(i in 1:confs) {
    cumul[i, 1:lmax] = parent_list[i,]
    
    Px = computePx(length(Y), as.matrix(X[,parent_list[i,]]), delta2) 
    post_prob = computePostProbNoChangePoints(dim(X)[1], v0, delta2, D, 
      q, length(which(parent_list[i,] != 0)), Y, Px)
    
    cumul[i, lmax+1] = post_prob;
  }
  
  norm_const = sum(cumul[,lmax+1]);
  cumul[,lmax+1] = cumul[,lmax+1]/norm_const;
  
  for(i in 1:confs) {
    index = paste(parent_list[i,], collapse=' ');
    probs[[index]] = cumul[i,lmax+1];
  }
  
  cumul[,lmax+1] = t(cumsum(cumul[,lmax+1]));
  
  post_probs = list()
  post_probs$cumul = cumul;
  post_probs$probs = probs;
  
  return(post_probs);
}
  
