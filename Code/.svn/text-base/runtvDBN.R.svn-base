  # Import code :


# AA: hä?? warum ändert sich codepath wieder zu dem alten standard pfad
codePath=paste(getwd(),"/Code/",sep="")
print(codePath)

  # +  main functions
  source(paste(codePath,"buildXY.R",sep=""))  
  source(paste(codePath,"init.R",sep=""))
  source(paste(codePath,"moves.R",sep=""))
  source(paste(codePath,"main.R",sep=""))
  source(paste(codePath,"output_main.R",sep=""))
  source(paste(codePath,"output_functions.R", sep=""))
  # +  useful tools
  source(paste(codePath,"hyperParms.R", sep=""))
  source(paste(codePath,"util.R",sep=""))#requires pseudoinverse
  source(paste(codePath,"sample_and_update.R",sep=""))#requires pseudoinverse  
  # +  external functions
  source(paste(codePath,"invGamma.R",sep=""))
  source(paste(codePath,"mvrnorm.R",sep=""))
  source(paste(codePath,"fast.svd.R",sep=""))
  source(paste(codePath,"pseudoinverse.R",sep=""))
  source(paste(codePath,"simulate_network.R",sep=""))
  source(paste(codePath,"convert.R",sep=""))
  
  ## AA: added - my PSRF edge functions
  source(paste(codePath,"Helper/psrf.R",sep=""))


##modifie par Sophie 01/03/09: ajout de parametres
##modifie par Sophie 01/03/09: ajout de targetNamesFile
##### Main function to use to run the whole program
runtvDBN <- function(targetdata, preddata=NULL, q, n, m,p=1,  dyn=0, 
  multipleVar=TRUE, minPhase=2, maxCP=min(n-1-dyn,15), maxTF=min(q,15), 
  nbCPinit=min(floor(n/2),5), CPinit=NULL, alphaCP=1, betaCP=0.5, alphaTF=1, 
  betaTF=0.5, pkCP=NULL, pkTF=NULL, posResponse=NULL, bestPosMatFile=NULL, 
  niter=20000, ndeb=1, nfin=niter, simpleOut=FALSE, BFOut=TRUE, Picture=TRUE, 
  Format=0, WriteStock=FALSE, secondModel=FALSE, predNamesFile=NULL, 
  targetNamesFile=NULL, kpriorsfile=paste(codePath,"k_priors.txt",sep=""), 
  outputFile="tvDBNoutput", birth_proposals=1, lmax=3, scaling=TRUE, networkid=NULL){
  # runtvDBN: run whole program
  # Description:
  #
  # Arguments:
  # targetdata = target data (either the name of a file, or directly a matrix)
  # preddata = optional, file with predictor data when differing from the target data (either the name of a file, or directly a matrix), default=NULL.
  # q = number of predictor variables
  # n = number of timepoints in the series (do not mention de repetitions)
  # m = number of repeated measurements for each timepoint
  # p = number of response variables (default=1)
  # dyn = delay (in timepoints) between TF and target (default=0)
  # multipleVar = TRUE when a specific variance is estimated for each phase, FALSE otherwise (default: TRUE).
  # minPhase = minimal length of a phase (>1 if no repetition, default: 2)
  # maxCP = maximal number of CP (default= min(n-1,15))
  # maxTF = maximal number of TF (default=min(q,15))
  # nbCPinit = number of CP at initialisation (default=min(floor(n/2),5))
  # CPinit = optional, initial chengpoint vector, default=NULL 
  # alphaCP, betaCP = hyperparms for sampling the number k of CP : k ~ Gamma(alphaCP,betaCP)  (default: alphaCP=0.5, betaCP =1). You can use function choosePriors to set alphaCP and  betaCP according to the desired dimension penalisation.
  # alphaTF, betaTF= hyperparms for sampling the number l of TF : l ~ Gamma(alphaTF,betaTF) (default: alphaTF=0.5, betaTF =1).  You can use function choosePriors to set alphaTF and  betaTF according to the desired dimension penalisation.
  # pkCP, pkTF = prior distribution for the nulmber of CP or TF (default=NULL, necessary when BFOut = TRUE and the hyperparameters alpha, beta are note among the one provided by the package, see choosePriors for the list of available hyperparameters).
  # posResponse = row position (in targetdata) of targets to be analyzed (default: analize all genes)
  # bestPosMatFile = file containing row position of predictors for each gene (see default below)
  # niter = number of iterations (default: 20000)
  # ndeb, nfin = start and end of the iterations considered in the analyzes (default: 1 and niter)
  # simpleOut = TRUE for simple output  (the chosen model is the most represented model)
  # BFOut = TRUE for Bayes Factor (BF) analysis (selected model has the number of changepoints with the highest BF and, for eacg pahse the number of TF with the highest BF) 
  # Picture = do you want output pictures ?
  # Format = output picture format (1=jpg, 0=eps)
  # WriteStock = do you want to store all results (all values of all parameters over the iterations) ?
  # secondModel = do you want the results of the second best model ?
  # predNamesFile = file containing the names of the predictor (matrix format) (by default rownames of preddata will be used)
  # outputFile = name of output file (default: tvDBNoutput)
  
  ##modifie par Sophie 30/07/09 : parms model retire, parms CPinit ajoute
  
  # fixed parameters
  # Position of each time point in the data (designed for the algorithm)
  # AA: a help vector that increments from Mphase[1] = 0 to Mphase[n+1]= n, where 'n' is the nr. of timepoints in the serie
  #     Mphase is used to map the indices from the data in R matrices to the data in the actual data (which uses 0 to start the first element)
  Mphase=seq(1,n*m+1,by=m)-dyn*m
  
  # nbVarMax = maximal number of variances (default: kmax, put it to 1 if the variance is the same for all phases)
  if(multipleVar){
	nbVarMax=maxCP+1
  }else{ 
	nbVarMax=1
  }

  
  ## Read input data, if its already a matrix (like right now), return same matrix
  targetData = readInput(targetdata)
  
  if(is.null(preddata)){
	predData=targetData
  }else{
	predData = readInput(preddata)
  }

  cat("Scaling Input data\n")
  # AA: Scaling centers and scales the data, so that mean=0 and sd=1. This is good for working with the data
  #     Note, watch out for very large values in data set, the can make "normal" values very small 
  if(scaling){
        # t(x) returns transpose of given matrix x
  	targetData = t(scale(t(targetData)))
  	predData = t(scale(t(predData)))
  }
  
  # few tests :
  # targetData and predData must have the same number of columns
  if(ncol(targetData) != ncol(predData)) stop("Target data and Pred data don t have the same number of columns\n")
  # the number of columns corresponds to n (timepoints) x m (repetitions)
  if(ncol(targetData) != n*m) stop("Number of columns incompatible with n and m\n")

  # list of genes analyzed :
  if(is.null(posResponse)){
    # analyze all rows of targetData
    posResponse = 1:nrow(targetData)
    cat("target list: \n")
    print.table(posResponse)
    cat("\n")
    print.table(targetData)
  }  

  # names of predictors
  if(is.null(predNamesFile)){
    # take rownames of predData
    predNames = row.names(predData)
  } else {
    # unless specified otherwise (names of q predictors for each gene)(matrix [nrow(predData) x q])
    if(is.character(predNamesFile) & file.exists(predNamesFile)){
      predNames = as.matrix(read.table(predNamesFile)[,1])
    } else {
      stop(paste("File", predNamesFile,"is incorrect or does not exist\n"))
    }
  }
  
 # Ajoute par Sophie 02/07/09 
 # names of targets
  if(is.null(targetNamesFile)){
    # take rownames of predData
    targetNames = row.names(targetData)
  } else {
    # unless specified otherwise (names of q predictors for each gene)(matrix [nrow(predData) x q])
    if(is.character(targetNamesFile) & file.exists(targetNamesFile)){
      targetNames = as.matrix(read.table(targetNamesFile)[,1])
    } else {
      stop(paste("File", targetNamesFile,"is incorrect or does not exist\n"))
    }
  }


  # Position of the predictor variables in the data for each response (matrix [nrow(targetData) x q]) 
  if(is.null(bestPosMatFile)) {

  # Dyn Orig
  bestPosMat = matrix(1:q, nrow(targetData), q, byrow=TRUE)
    
    
    # AA-STATCH (06/08/10): since we do all static here we want to exclude the target node as predictor for the target
    # buildXY overrides this anyways, delete!
#    bestPosMat = matrix(nrow=0,ncol=q-1)
#    for(node in 1:nrow(targetData)) {
#      bestPosMat = rbind(bestPosMat, c(1:q)[-node])
#    }
    
    
    
  } else {
    # unless specified in bestPosMatFile
    if(is.character(bestPosMatFile) & file.exists(bestPosMatFile)){
      bestPosMat = read.table(bestPosMatFile)
    } else {
      stop(paste("File", bestPosMatFile,"is incorrect or does not exist\n"))
    }
  }


                                        # Output directory path (if it doesn t exist create it)
  path = paste(getwd(), "/", sep="")
  #if(! "Results" %in% system("ls" ,intern=TRUE)) { system(paste("mkdir ", path,"Results", sep="")) }
  outputPath=paste(path,"Results/",sep="")
 
   # Output Results directory path (for the most striking results: postDist and Bayes Factor)(if it doesn t exist create it)
  #if(! "MainResults" %in% system(paste( "ls ",outputPath),intern=TRUE)) { system(paste("mkdir ",outputPath,"MainResults",sep="")) }
  outputResPath=paste(outputPath,"MainResults/",sep="")
  
   # Output Stocks directory path (to store the other results of the procedure) (if it doesn t exist create it) 
  #if(! "Stock" %in% system(paste( "ls ",outputPath),intern=TRUE)) { system(paste("mkdir ",outputPath,"Stock",sep="")) }
  outputStockPath=paste(outputPath,"Stock/",sep="")

  ### Create Global Variables used in all functions
  ### modifie par Sophie 02/07/09 :Ajout de PredNames et TargetNames
  GLOBvar = list(n=n, m=m, p=p, q=q, qmax=maxTF, smax=maxCP, dyn=dyn, 
    minPhase=minPhase, nbVarMax=nbVarMax, Mphase=Mphase, bestPosMat=bestPosMat, 
    niter=niter, target=NULL,predNames=predNames, targetNames=targetNames, 
    birth_proposals=birth_proposals, lmax=lmax, networkid=networkid)

  ##modifie par Sophie 01/03/09
  ### Create HyperParms Variables used in all functions
  ##HYPERvar = HyperParms(model)
  #if(is.null(model)){
  HYPERvar = HyperParms(alphaCP, betaCP, alphaTF, betaTF, pkCP, pkTF, kpriorsfile, n, q, maxCP, maxTF, dyn, BFOut)
  #}else{
  #  HYPERvar = HyperParms(model)
  #}

  
  ### Create Output Variables used in output functions
  OUTvar = list(ndeb=ndeb, nfin=nfin, outputFile=outputFile, outputStockPath=outputStockPath, outputResPath=outputResPath, Picture=Picture, Format=Format, WriteStock=WriteStock, secondModel=secondModel, simple=simpleOut, BF=BFOut, BFthres=c(3,12))


	
  ### Manage allouput
  AllBestE = NULL
  AllBestModels = NULL

  ## ouput column names, [AA: prepare output files]
  if(OUTvar$simple){ 	
	  #Output Edges list col.names
	  outfile = paste(outputResPath, outputFile, "_0_OutSimple_EdgesList.txt",sep="")
      write.table(matrix(c("Parent #", "Parent name", "Target #", "Target name", "Start", "End"),1,6),file=outfile,col.names=F,row.names=F)

     # Output CP list col.names
     outfile = paste(outputResPath, outputFile, "_0_OutSimple_CPlist.txt",sep="")
     write.table(matrix(c("Target #", "Target name","CP position"), 1, 3),file=outfile,col.names=F,row.names=F)
  }
  
  if(OUTvar$BF){ 	
	  #Output Edges list col.names
	  outfile = paste(outputResPath, outputFile, "_0_OutBF_EdgesList.txt",sep="")
      write.table(matrix(c("Parent #", "Parent name", "Target #", "Target name", "Start", "End", "Edge_BF"),1,7),file=outfile,col.names=F,row.names=F)

     # Output CP list col.names
     outfile = paste(outputResPath, outputFile, "_0_OutBF_CPlist.txt",sep="")
     write.table(matrix(c("Target #", "Target name","CP position", "CP_BF", "nbCP_BF"), 1, 5),file=outfile,col.names=F,row.names=F)
 		
     #print("Prior distribution for the number of CP :")
     #print(HYPERvar$pkCP)
     #print("Prior distribution for the number of incoming edges (TF) :")
     #print(HYPERvar$pkTF)
   }

  rocpp = matrix(nrow=0, ncol=nrow(targetData))
  StructAndCPs = list(Sstocks=list(),Estocks=list(), target=0,network=0) 

  
  # Execute Simulation for each target here
  for(target in posResponse){

    cat("Target node: ", target, "\n")
    
    # update global variables with target
    GLOBvar$target=target
    
    ## build response Y and predictor X
    input = buildXY(targetData, predData, GLOBvar)
    X = input$X
    Y = input$Y
    
    ## initialize system
    initiation = init(X, Y, nbCPinit, GLOBvar, HYPERvar, CPinit)
    print("Initialisation ok")
    
	
    ## run niter iterations
    print("Starting tvDBN iterations...")
    runiteration = main(X, Y, initiation, GLOBvar, HYPERvar)
    print("---------------------------------------------------")
    print("End of iterations")


    # AA: save the Sstocks and Estocks (required for ROC/PREC)
        
    StructAndCPs$Sstocks = runiteration$listStock$Sstock
    StructAndCPs$Estocks = runiteration$listStock$Estock
    StructAndCPs$target = GLOBvar$target
    StructAndCPs$network = GLOBvar$networkid
    
    save(StructAndCPs, file = paste("./Results/StructData/Struct_Network_n", GLOBvar$networkid, "_i", GLOBvar$target, sep=""))

  }
  
}
 
