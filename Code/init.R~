#initialisation
init <- function(X, Y, GLOBvar, HYPERvar){
  ### assignement of global variables used here ###
  niter = GLOBvar$niter
  smax = GLOBvar$smax
  q = GLOBvar$q
  ### end assignement ###
  
  
  ## counting CP moves (CP Birth, CP death, CP move, Updating phases)
  cptMove2 = array(0,4)
  acceptMove2 = array(0,4)

  ## counting "Updating phases" moves (Edge Birth, Edge death, Udating regression coefficient)
  cptMove = array(0,3)
  acceptMove = array(0,3)

  counters = list(cptMove2=cptMove2, acceptMove2=acceptMove2, cptMove=cptMove, acceptMove=acceptMove)
  
  ## Initialisation of first iteration parameters
  initState = sampleParms(X, GLOBvar, HYPERvar) 

  ## Calculate the first delta2, only can do this after initState is set
  cat("fixme: init the delta2!")
  delta2 = 0.1

  
  ## AABIG: only do it for birth_proposal 4, since this gets also too large and we do not need it (birth_proposal 2) 
  post_probs = 0
  if(GLOBvar$birth_proposal == 4) {
    post_probs = calculatePostProbs(X, Y, sinit, GLOBvar, HYPERvar);
  }
  
  return(list(counters=counters, initState=initState, listStock=list(), post_probs = post_probs, delta2=delta2))
}


calculatePostProbs <- function(X, Y, l, GLOBvar, HYPERvar){
	
  q = GLOBvar$q
  lmax = GLOBvar$lmax
	
### assignement of hyperparameters variables used here ###
  alphad2 = HYPERvar$alphad2
  betad2 = HYPERvar$betad2
  alphaD = HYPERvar$alphaD
  betaD = HYPERvar$betaD
### end assignement ###
  v0 = HYPERvar$v0

  # gamma distribution, shape and rate (inverse of scale)
  D = rgamma(1, shape=alphaD, rate = betaD)

  # inverse gamma distribution (custom: see invGamma.R)
  delta2 = rinvgamma(1, shape=alphad2, scale=betad2) 
  
  parent_list = matrix(0, 1, lmax);

  # the parent list, where ist it used?
  for (parent_no in 1:lmax) {

    combs = t(combn(1:q, parent_no));
    new_parent_list = matrix(0, dim(combs)[1], lmax);
    
    new_parent_list[,(lmax-parent_no+1):lmax] = combs;
    
    parent_list = rbind(parent_list, new_parent_list);
  }
  
  confs = dim(parent_list)[1];
  
  cumul = matrix(0, confs, lmax + 1)
  probs = list();
  
  for(i in 1:confs) {
    cumul[i, 1:lmax] = parent_list[i,]
    
    Px = computePx(length(Y), as.matrix(X[,parent_list[i,]]), delta2) 
    post_prob = computePostProbNoChangePoints(dim(X)[1], v0, delta2, D, 
      q, length(which(parent_list[i,] != 0)), Y, Px)
    
    cumul[i, lmax+1] = post_prob;
  }
  
  norm_const = sum(cumul[,lmax+1]);
  cumul[,lmax+1] = cumul[,lmax+1]/norm_const;
  
  for(i in 1:confs) {
    index = paste(parent_list[i,], collapse=' ');
    probs[[index]] = cumul[i,lmax+1];
  }
  
  cumul[,lmax+1] = t(cumsum(cumul[,lmax+1]));
  
  post_probs = list()
  post_probs$cumul = cumul;
  post_probs$probs = probs;
  
  return(post_probs);
}
  
