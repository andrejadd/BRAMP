

  ###### product of posterior prob of current state : Phi_h
  ##
  #prodPhi = 1     # product over current state
  sumPhi = 0
  
  ## 1. extract parameters that are in the segment
  if(ALTERX) { xsegid = poskl } else { ysegid = poskl }
  
  for(i in 1:(length(OtherE)-1)) {

    if(ALTERX) { ysegid = i } else { xsegid = i }
    
     ## get segment coordinates
    segcoord = c(XMphase[XE[xsegid]], YMphase[YE[ysegid]],XMphase[XE[xsegid+1]]-1, YMphase[YE[ysegid+1]]-1)


    if(DEBUG_BIRTH_EXT == TRUE) { cat("xsegid: ", xsegid, ", ysegid: ", ysegid, "\n");
                                  cat("prodPhi: segcoord ")
                                  print.table(segcoord) }
    
    ## get the predictor data
    x = extractXPredictors(X, segcoord, xlocs,F)

    ## get the target data
    y = extractYTargets(Y, segcoord, xlocs,F)
   
    ## number of locations
    omega = length(y)

    ## calculate projection matrix
    Pr = computePx(omega, as.matrix(x[,which(S2Dall == 1)]), delta2)

    #prodPhi = prodPhi * gamma((v0+omega)/2) * ((gamma0+ t(y) %*% Pr %*% y)/2)^(-(v0+omega)/2)
    sumPhi  = sumPhi  + lgamma((v0+omega)/2) + (-(v0+omega)/2) * log( (gamma0+ t(y) %*% Pr %*% y)/2)

  
  }


  ###### product of posterior prob of next state : Phi^+_h
  ##
  #prodPhiPlus = 1 # over next state
  sumPhiPlus = 0
  
  for(xsegid in poskl:(poskl+1)) {

    for(i in 1:(length(OtherE)-1)) {

      ## we need to replace one of the CP vectors with the new Eplus vector temporary for the segcoord extraction
      if(ALTERX) { ysegid = i; tmpXE = Eplus; tmpYE = OtherE } else { xsegid = i;  tmpXE = OtherE; tmpYE = Eplus }
    
      ## get segment coordinates
      segcoord = c(XMphase[tmpXE[xsegid]], YMphase[tmpYE[ysegid]],XMphase[tmpXE[xsegid+1]]-1, YMphase[tmpYE[ysegid+1]]-1)

      if(DEBUG_BIRTH_EXT == TRUE) { cat("xsegid: ", xsegid, ", ysegid: ", ysegid, "\n");
                                    cat("prodPhiPlus: segcoord ")
                                    print.table(segcoord) }
      ## get the predictor data
      x = extractXPredictors(X, segcoord, xlocs,F)
      
      ## get the target data
      y = extractYTargets(Y, segcoord, xlocs,F)
      
      ## number of locations
      omega = length(y)
      
      ## calculate projection matrix
      Pr = computePx(omega, as.matrix(x[,which(S2Dall == 1)]), delta2)

    #  prodPhiPlus = prodPhiPlus * gamma((v0+omega)/2) * ((gamma0+ t(y) %*% Pr %*% y)/2)^(-(v0+omega)/2)
      sumPhiPlus  = sumPhiPlus  + lgamma((v0+omega)/2) + (-(v0+omega)/2) * log( (gamma0+ t(y) %*% Pr %*% y)/2)


    }
}

  ## nr edges s
  s = sum(S2Dall) - 1

  ## nr CPs k
  k = length(E) - 2

  ## this is the exponent |Phi+| - |Phi| = |Phi| = k of other axis, in eq. (15), since |Phi+| = 2|Phi| and |Phi_h| = |CPs other axis|   
  dSegmentNr = length(OtherE) - 1

#  alpha1a =  D / (c - 1 - k) * ( (gamma0/2)^(v0/2) / (gamma(v0/2) * (delta2+1)^((s+1)/2) ))
#  alpha1b = prodPhiPlus / prodPhi
  
#  alpha2a =  log(D / (c - 1 - k))+(v0/2)*log(gamma0/2) - lgamma(v0/2) - log((delta2+1)^((s+1)/2)) 
#  alpha2b = sumPhiPlus - sumPhi

#  alpha1 = D / (c - 1 - k) * ( (gamma0/2)^(v0/2) / (gamma(v0/2) * (delta2+1)^((s+1)/2) ))^dSegmentNr *  prodPhiPlus / prodPhi
  alpha = exp(  log(D / (c - 1 - k)) + dSegmentNr *( (v0/2)*log(gamma0/2) - lgamma(v0/2) - log((delta2+1)^((s+1)/2))) + sumPhiPlus - sumPhi)

