#####################################################################################
## BIRTH OF A CHANGEPOINT
#####################################################################################

cp.birth <- function(ALTERX, XE, YE, S2Dall, B2Dall, Sig2_2Dall, X, Y, D, GLOBvar, HYPERvar, DEBUGLVL1 = F, DEBUG_BIRTH_EXT = F) {
  
  ### assignement of global variables used here ###
  q = GLOBvar$q
  qmax = GLOBvar$qmax
  minPhase = GLOBvar$minPhase
  nbVarMax = GLOBvar$nbVarMax
  smax = GLOBvar$smax
  dyn = GLOBvar$dyn
  XMphase = GLOBvar$XMphase
  YMphase = GLOBvar$YMphase
  birth_proposal = GLOBvar$birth_proposals
  nrsegments = dim(Segments)[1]
  xlocs = GLOBvar$xlocs
  ylocs = GLOBvar$ylocs
  
  ### end assignement ###

  ### assignement of hyperparameters variables used here ###
  alphalbd = HYPERvar$alphalbd
  betalbd = HYPERvar$betalbd
  alphad2 = HYPERvar$alphad2
  betad2 = HYPERvar$betad2
  v0 = HYPERvar$v0
  gamma0 = HYPERvar$gamma0
  delta2 = HYPERvar$delta2

  ### end assignement ###

  if(DEBUG_BIRTH_EXT == TRUE) { cat("\n START CP.BIRTH\n\n") }

  ## assign the changepoint vector of interest
  if(ALTERX) { E = XE } else { E = YE } 
  
  ## search for possible CP, not in E and not close to E if minPhase (length of phase) is > than 1
  toremove = E
  if(minPhase>1) for(i in 1:(minPhase-1)) toremove = c(toremove, E-i, E+i)
  if(DEBUG_BIRTH_EXT == TRUE) { cat("toremove (impossible CP): ", toremove, "\n") }

  ## possible CPs are those not in 'toremove'
  possibleCP = setdiff((1+dyn):E[length(E)], toremove)
  if(DEBUG_BIRTH_EXT == TRUE) { cat("possibleCP: ", possibleCP, "\n") }

  ## check if a valid cp position exists or sample() will fail
  if(length(possibleCP)== 0) {
    return(list(XE=XE, YE=YE, S2Dall=S2Dall, B2Dall=B2Dall, Sig2_2Dall=Sig2_2Dall, accept=0, move=1, alpha=0, estar=-1))
  }
  
  # sample the new CP "estar"
  # AA: returns 1 (size=1) random CP from the possibleCP list
  #  why is the possibleCP list doubled?
  estar = sample(c(possibleCP, possibleCP),1)
  if(DEBUG_BIRTH_EXT == TRUE) { cat("CP estar (one random possibleCP): ", estar, "\n") }

  ## Create next state CP vector
  Eplus = sort(c(E,estar))
  if(DEBUG_BIRTH_EXT == TRUE) {  cat("next state CP vector: "); print.table(Eplus) }
    
  ## Position of the phase containing the new CP
  poskl = sum(E < estar)

  if(DEBUG_BIRTH_EXT == TRUE) { cat("poskl (pos. of phase containing new CP): ", poskl, "\n") }

  if(ALTERX) {OtherE = YE} else { OtherE = XE}
  alpha = cp.computeAlpha(1, X, Y, xlocs, ylocs, ALTERX, XMphase, YMphase, E, Eplus, OtherE,  poskl, HYPERvar, S2Dall, D, DEBUG_BIRTH_EXT) 

  
   #alpha
  if(DEBUG_BIRTH_EXT == TRUE) { cat("[ ] acceptation probability alpha: ", alpha, "\n") }
  
  ## Sample u to conclude either to  acceptation or to rejection
  u = runif(1,0,1)
  
  ## Boolean for the acceptation of the CP birth move initially set to 0 (=1 if birth accepted, 0 otherwise)
  accept = 0

  
  if(!is.nan(alpha) & u <= alpha){
#  if(1) {
  ## Acceptation of the birth of the new CP
    ## Move acceptation boolean =1
    accept=1

    if(DEBUGLVL1) { cat("b") }
    
    if(DEBUG_BIRTH_EXT == TRUE) { cat("[birth] edge accepted!\n") }

    ## I will assume that the new segment is the right one. this is simplified but if to follow the 1D approach one
    ## would have to choose among more than 2 neighbors for the new segment. This can be of course done in some sort of local shuffle
    ## However, the structure stays the same and the regress. coefficient and variance (sigma2) are updated in any case in later iterations
    ## We assume poskl to hold the "old" segment and poskl+1 the new

    ## First increment the segment ids of segments that are greater than the inserted segments
    if(ALTERX) { colmn = 1 } else { colmn = 2}  # select the column

    Sig2_2Dall[which(Sig2_2Dall[,colmn] > poskl),colmn] = Sig2_2Dall[which(Sig2_2Dall[,colmn] > poskl),colmn] + 1
    B2Dall[which(B2Dall[,colmn] > poskl),colmn] = B2Dall[which(B2Dall[,colmn] > poskl),colmn] + 1


    ## sets the new segments segment id, and updates the new changepoint vector
    if(ALTERX) { xsegid = poskl+1; XE = Eplus; nrOtherSegs = length(YE) - 1  } else { ysegid = poskl+1; YE = Eplus; nrOtherSegs = length(XE) - 1 }
  
    for(i in 1:nrOtherSegs) {

      if(ALTERX) { ysegid = i; } else { xsegid = i; }
   
      ## get segment coordinates
      segcoord = c(XMphase[XE[xsegid]], YMphase[YE[ysegid]],XMphase[XE[xsegid+1]]-1, YMphase[YE[ysegid+1]]-1)

      if(DEBUG_BIRTH_EXT == TRUE) { cat("xsegid: ", xsegid, ", ysegid: ", ysegid, "\n");
                                    cat("prodPhiPlus: segcoord ")
                                    print.table(segcoord) }
      
      
      x = extractXPredictors(X, segcoord, xlocs,F)
      y = extractYTargets(Y, segcoord, xlocs,F)
      Pr = computePx(length(y), as.matrix(x[,which(S2Dall == 1)]), delta2)
      
      ## variance
      newSig2 = sampleSig2(y,Pr,v0,gamma0)
      Sig2_2Dall = rbind(Sig2_2Dall, c(xsegid, ysegid, newSig2))
      
      ## regression coefficient
      newB = array(0,q + 1)
      newB[which(S2Dall == 1)] = sampleBxy(x[,which(S2Dall==1)], y, newSig2, delta2)
      B2Dall = rbind(B2Dall, c(xsegid, ysegid, newB))

      if(DEBUG_BIRTH_EXT == TRUE) {  cat("[accepted] new regression parameters newB: \n"); print.table(newB)  }

    }

    if(DEBUG_BIRTH_EXT == TRUE) {  cat("Sig2_2Dall: "); print.table(Sig2_2Dall);
                                   cat("B2Dall: ");     print.table(B2Dall); }
                                   


    
  } else {
    if(DEBUG_BIRTH_EXT == TRUE) { cat("[no birth] edge not accepted! returning..\n") }
  }

  ##  Return all variables
  ## (+ variable move describing the move type  (1= CP birth, 2= CP death, 3= CP shift, 4= Update phases)
  return(list(XE=XE, YE=YE, S2Dall=S2Dall, B2Dall=B2Dall, Sig2_2Dall=Sig2_2Dall, accept=accept, move=1, alpha=alpha, estar=estar))

}


#####################################################################################
#DEATH OF A CHANGEPOINT
#####################################################################################

cp.death <- function(ALTERX, XE, YE, S2Dall, B2Dall, Sig2_2Dall, X, Y, D, GLOBvar, HYPERvar, DEBUGLVL1 = F, DEBUG_BIRTH_EXT = F) {

  ### assignement of global variables used here ###
  q = GLOBvar$q
  nbVarMax = GLOBvar$nbVarMax
  smax = GLOBvar$smax
  qmax = GLOBvar$qmax
  xlocs = GLOBvar$xlocs
  ylocs = GLOBvar$ylocs
  XMphase = GLOBvar$XMphase
  YMphase = GLOBvar$YMphase

### end assignement ###

  ### assignement of hyperparameters variables used here ###
  alphad2 = HYPERvar$alphad2
  betad2 = HYPERvar$betad2
  v0 = HYPERvar$v0
  gamma0 = HYPERvar$gamma0
  ### end assignement ###

  if(DEBUG_BIRTH_EXT == TRUE) { cat("\n START CP.DEATH\n\n") }

  if(ALTERX) { E = XE;   if(DEBUG_BIRTH_EXT == TRUE) { cat("ALTERX = TRUE\n") } } else { E = YE;   if(DEBUG_BIRTH_EXT == TRUE) { cat("ALTERX = FALSE\n") } }
  
  ## check if there are at least one possible CP (should never happen that this fct gets selected for run but just to prevent worsed case and crash)
  if(length(E) < 3) {
    if(DEBUG_BIRTH_EXT == TRUE) { cat("no CP can be removed, returning..\n") }
    return(list(XE=XE, YE=YE, S2Dall=S2Dall, B2Dall=B2Dall, Sig2_2Dall=Sig2_2Dall, accept=0, move=2, alpha=0, estar=-1))
  }
  
  ## Sample the CP to be removed
  estar = sample(c(E[2:(length(E)-1)], E[2:(length(E)-1)]), 1)
  if(DEBUG_BIRTH_EXT == TRUE) { cat("estar: ", estar, "\n") }

  ##  Position of the phase starting at the selected CP
  poskstar = sum(E <= estar)
  if(DEBUG_BIRTH_EXT == TRUE) { cat("poskstar: ", poskstar, "\n") }

  ## CP changepoint vector without the CP
  Eminus = E[-which(E == estar)]
  if(DEBUG_BIRTH_EXT == TRUE) { cat("Eminus: "); print.table(Eminus) }
  if(DEBUG_BIRTH_EXT == TRUE) { cat("E: "); print.table(E) }
  

  ## Prepare the data,
  if(ALTERX) {OtherE = YE} else { OtherE = XE}
  if(DEBUG_BIRTH_EXT == TRUE) { cat("OtherE: "); print.table(OtherE) }

  ## compute the acceptance probability
  alpha = cp.computeAlpha(-1, X, Y, xlocs, ylocs, ALTERX, XMphase, YMphase, E=Eminus, Eplus=E, OtherE,  poskl=(poskstar-1), HYPERvar, S2Dall, D, DEBUG_BIRTH_EXT) 

  ## Sample u to conclude either to  acceptation or to rejection
  u = runif(1,0,1)

  ## Boolean for the acceptation of the CP death move initially set to 0 (=1 if birth accepted, 0 otherwise)
  accept = 0
  
  if(!is.nan(alpha) & u <= alpha){
#  if(1) {

    ## Acceptation of the death of the selected CP, Move acceptation boolean =1
    accept=1

    ## update the CP vector
    if(ALTERX) { XE = Eminus} else { YE = Eminus}

    ## AA: Need to decide which parameter segments to keep, naturally and simply would be (poskstar - 1) - this segment id would stay
    ## when merging [(poskstar - 1),poskstar], although, we could allow the parameters of the larger segment to stay.
    ## But anyways, update of the parameters will take place later. This might only influence convergence a little

    if(DEBUG_BIRTH_EXT == TRUE) {  cat("before Sig2_2Dall: "); print.table(Sig2_2Dall);
                                   cat("before B2Dall: ");     print.table(B2Dall); }

    ## delete the parameters with segid poskstar
    if(ALTERX) { colmn = 1 } else { colmn = 2}  # select the column
    B2Dall =     B2Dall[which(B2Dall[,colmn] != poskstar),,drop=F]     # drop=F makes sure the matrix is not transformed to vector when single row is left
    Sig2_2Dall = Sig2_2Dall[which(Sig2_2Dall[,colmn] != poskstar),, drop=F]

    ## decrement the segments that are greater poststar in order to fill the gap of the now morged segments
    Sig2_2Dall[which(Sig2_2Dall[,colmn] > poskstar),colmn] = Sig2_2Dall[which(Sig2_2Dall[,colmn] > poskstar),colmn] -1 
    B2Dall[which(B2Dall[,colmn] > poskstar),colmn] = B2Dall[which(B2Dall[,colmn] > poskstar),colmn] - 1

    if(DEBUG_BIRTH_EXT == TRUE) {  cat("Sig2_2Dall: "); print.table(Sig2_2Dall);
                                   cat("B2Dall: ");     print.table(B2Dall); }


  }

  if(DEBUG_BIRTH_EXT == TRUE) { cat("\n-- END CP.DEATH --\n\n") }


  ##  Return all variables
  ## (+ variable move describing the move type  (1= CP birth, 2= CP death, 3= CP shift, 4= Update phases)
  return(list(XE=XE, YE=YE, S2Dall=S2Dall, B2Dall=B2Dall, Sig2_2Dall=Sig2_2Dall, accept=accept, move=2, alpha=alpha, estar=estar))
}

                                  

#####################################################################################
#MOVE OF A CHANGEPOINT
#####################################################################################


cp.shift <- function(ALTERX, XE, YE, S2Dall, B2Dall, Sig2_2Dall, X, Y, GLOBvar, HYPERvar, DEBUGLVL1 = F, DEBUG_BIRTH_EXT = F) {
  
  ### assignement of global variables used here ###
  q = GLOBvar$q
  minPhase = GLOBvar$minPhase
  nbVarMax = GLOBvar$nbVarMax
  smax = GLOBvar$smax
  xlocs = GLOBvar$xlocs
  ylocs = GLOBvar$ylocs
 XMphase = GLOBvar$XMphase
  YMphase = GLOBvar$YMphase
  
  ### end assignement ###

  ### assignement of hyperparameters variables used here ###
  alphad2 = HYPERvar$alphad2
  betad2 = HYPERvar$betad2
  v0 = HYPERvar$v0
  gamma0 = HYPERvar$gamma0
  delta2 = HYPERvar$delta2
  ### end assignement ###
  
  
  ## Select two segments that have adjacent boundaries, this boundary corresponds to a CP that can be shifted
  ## Makes use of the segment pair search cp.death

  if(DEBUG_BIRTH_EXT == TRUE) { cat("\n START CP.SHIFT\n\n") }

  if(ALTERX) { E = XE;   if(DEBUG_BIRTH_EXT == TRUE) { cat("ALTERX = TRUE\n") } } else { E = YE;   if(DEBUG_BIRTH_EXT == TRUE) { cat("ALTERX = FALSE\n") } }
  if(DEBUG_BIRTH_EXT == TRUE) { cat("E: "); print.table(E) }
    
  ## check if there are at least one possible CP to shift 
  if(length(E) < 3) {
    if(DEBUG_BIRTH_EXT == TRUE) { cat("nothing to shift, returning..\n") }
    return(list(XE=XE, YE=YE, S2Dall=S2Dall, B2Dall=B2Dall, Sig2_2Dall=Sig2_2Dall, accept=0, move=2, alpha=0, estar=-1))
  }


  ## Sample the CP to be shifted
  estar = sample(c(E[2:(length(E)-1)], E[2:(length(E)-1)]), 1)
  if(DEBUG_BIRTH_EXT == TRUE) { cat("estar: ", estar, "\n") }

  ## Position of the phase starting at the selected CP
  poskstar = sum(E <= estar)
  if(DEBUG_BIRTH_EXT == TRUE) { cat("poskstar: ", poskstar, "\n") }

  ## Possible new position for the selected CP (CP-1, CP+1)
  newCPs = c(E[poskstar]-1,E[poskstar]+1)
  if(DEBUG_BIRTH_EXT == TRUE) { cat("newCPs: ", newCPs, "\n") }

  if(DEBUG_BIRTH_EXT == TRUE) { cat("newCPs: "); print.table(c(E[poskstar-1],E[poskstar-1]+minPhase-1, E[poskstar+1],E[poskstar+1]-minPhase+1,E)) }
  
  ## remove positions that create too short segments (minPhase)
  newCPs = newCPs[which( !( newCPs %in% c(E[poskstar-1],E[poskstar-1]+minPhase-1, E[poskstar+1],E[poskstar+1]-minPhase+1,E)))]
  if(DEBUG_BIRTH_EXT == TRUE) { cat("newCPs: ", newCPs, "\n") }
  
  ## Boolean for the acceptation of the CP shift move initially set to 0 (=1 if birth accepted, 0 otherwise)
  accept = 0
  
  ## If there is at least one option to shift the selected CP 
  if(length(newCPs) > 0){

    ## Sample new CP position
    newCP = sample( c(newCPs, newCPs), 1)
    if(DEBUG_BIRTH_EXT == TRUE) { cat("newCP: ", newCP, "\n") }
    
    ## new CP vector
    Eshift = E
    Eshift[poskstar] = newCP
    if(DEBUG_BIRTH_EXT == TRUE) { cat("Eshift: "); print.table(Eshift)  }
    
    ###
    ## Calculate the current state posterior, unshifted

    prodPhi = 1     # product over current state
    sumPhi = 0
  
    ## Assign proper CP vector to temporary type (used in segcoord extraction)
    if(ALTERX) {tmpYE = OtherE = YE; tmpXE = E } else { tmpXE = OtherE = XE; tmpYE = E }
    if(DEBUG_BIRTH_EXT == TRUE) { cat("OtherE: "); print.table(OtherE)  }
    
    
    for(j in (poskstar-1):poskstar) {
      
      for(i in 1:(length(OtherE)-1)) {

        ## Assign proper segment id
        if(ALTERX) { xsegid = j; ysegid = i } else { xsegid = i; ysegid = j}
      
        ## get segment coordinates
        segcoord = c(XMphase[tmpXE[xsegid]], YMphase[tmpYE[ysegid]],XMphase[tmpXE[xsegid+1]]-1, YMphase[tmpYE[ysegid+1]]-1)

        if(DEBUG_BIRTH_EXT == TRUE) {  cat("[prodPhi] xsegid: ", xsegid, ", ysegid: ", ysegid, ",  segcoord ")
                                       print.table(segcoord) }
        ## get the predictor data
        x = extractXPredictors(X, segcoord, xlocs,F)
        
        ## get the target data
        y = extractYTargets(Y, segcoord, xlocs,F)
        
        ## number of locations
        omega = length(y)
        
        ## calculate projection matrix
        Pr = computePx(omega, as.matrix(x[,which(S2Dall == 1)]), delta2)
        
        prodPhi = prodPhi * gamma((v0+omega)/2) * ((gamma0+ t(y) %*% Pr %*% y)/2)^(-(v0+omega)/2)
        sumPhi  = sumPhi  + lgamma((v0+omega)/2) + (-(v0+omega)/2) * log( (gamma0+ t(y) %*% Pr %*% y)/2)

      }
    }

    ##
    ## Calculate the next state posterior, shifted
    ## NOTE, this is exactly the same as with current state, only the Eshift assigned as tmpXE or tmpYE
    prodPhiPlus = 1     # product over current state
    sumPhiPlus = 0
  
    ## Assign proper CP vector to temporary type (used in segcoord extraction)
    if(ALTERX) {tmpXE = Eshift } else { tmpYE = Eshift }
    
    for(j in (poskstar-1):poskstar) {
      
      for(i in 1:(length(OtherE)-1)) {

        ## Assign proper segment id
        if(ALTERX) { xsegid = j; ysegid = i } else { xsegid = i; ysegid = j}
      
        ## get segment coordinates
        segcoord = c(XMphase[tmpXE[xsegid]], YMphase[tmpYE[ysegid]],XMphase[tmpXE[xsegid+1]]-1, YMphase[tmpYE[ysegid+1]]-1)

        if(DEBUG_BIRTH_EXT == TRUE) {  cat("[prodPhi] xsegid: ", xsegid, ", ysegid: ", ysegid, ",  segcoord ")
                                       print.table(segcoord) }
        ## get the predictor data
        x = extractXPredictors(X, segcoord, xlocs,F)
      
        ## get the target data
        y = extractYTargets(Y, segcoord, xlocs,F)
      
        ## number of locations
        omega = length(y)
      
        ## calculate projection matrix
        Pr = computePx(omega, as.matrix(x[,which(S2Dall == 1)]), delta2)

        prodPhiPlus = prodPhiPlus * gamma((v0+omega)/2) * ((gamma0+ t(y) %*% Pr %*% y)/2)^(-(v0+omega)/2)
        sumPhiPlus  = sumPhiPlus  + lgamma((v0+omega)/2) + (-(v0+omega)/2) * log( (gamma0+ t(y) %*% Pr %*% y)/2)

      }
    }

    ## Computation of the proposal Ratio:
    ##
    ## This operation corresponds to (kW - e) / (kW - e*) at the end of Eq. 4.25, where 'e' is the number of impossible position changes
    ## e  = sum(((E[2:(s+2)]-E[1:(s+1)]) <= minPhase) * nbmove)
    ## e* = sum(((Estar[2:(s+2)]-Estar[1:(s+1)]) <= minPhase) * nbmove)
    ## W = 2
    ## k = nr. of segments
    ##
    ## In consequence: (2*s-sum(((E[2:(s+2)]-E[1:(s+1)]) <= minPhase) * nbmove)) = W*k - e -> nr. of possible shift
    ## ---> The ratio is larger than 1 if the shift decreases the nr. of possible shifts and smaller than one if the shift introduces more shift opportunities
    
    ## Vector of length the current number of phases= c(1,2,2,...,2,2,1) i.e. the number of CP that can potentially be shifted into each phase
    k = length(E) - 2
    nbmove = c(1,array(2,k-1),1)
    propRatio = (2*k-sum(((E[2:(k+2)]-E[1:(k+1)]) <= minPhase) * nbmove))/(2 * k - sum(((Eshift[2:(k+2)]-Eshift[1:(k+1)]) <= minPhase) * nbmove))


    ## calculate acceptance probability
    #alpha1 = prodPhiPlus / prodPhi 
    logLR = sumPhiPlus - sumPhi

    if(DEBUG_BIRTH_EXT == TRUE) {  cat("logLR: ", logLR, ", propRatio: ", propRatio, "\n");
                                   cat("logLR + log(propRatio): ", logLR+log(propRatio), ", exp(..): ", exp(logLR+log(propRatio)), "\n");
                                   cat("exp(logLR)*propRatio: ", exp(logLR)*propRatio, "\n")
                                 }

    
    ## Computation of alpha
    if(!is.nan(logLR) & (logLR+log(propRatio))<0){ # in case adding up the log yields < 0
      alpha = min(c(1, exp(logLR)*propRatio)) # do none log calculation
    } else { # else alpha would be higher than 1 , because exp(0) = 1, so we can set it anyways
      alpha = 1
    }


    ## Sample u to decide whether the CP shift is accepted or not
    u = runif(1,0,1)

    ## Boolean for the acceptation of the CP death move (=1 if birth accepted, 0 otherwise)

    if(u <= alpha){
      ## Acceptation of the death of the selected CP
      ## Move acceptation boolean =1
      accept = 1

      ## save new CP vector
      if(ALTERX) { XE = Eshift } else { YE = Eshift }
 
      if(DEBUGLVL1== TRUE) { cat("s") }
      
    }
   } 

     
  if(DEBUG_BIRTH_EXT == TRUE) { cat("\n END CP.SHIFT\n\n") }
  
  ##  Return all variables
  ## (+ variable move describing the move type  (1= CP birth, 2= CP death, 3= CP shift, 4= Update phases)
  return(list(XE=XE, YE=YE, S2Dall=S2Dall, B2Dall=B2Dall, Sig2_2Dall=Sig2_2Dall, accept=accept, move=3))
}


###################################################################
# Update phases
###################################################################

phase.update <- function(XE, YE, S2Dall, B2Dall, Sig2_2Dall, X, Y, GLOBvar, HYPERvar,  DEBUGLVL1 = F, DEBUGLVL2 = F ) {

  
  
  ### assignement of global variables used here ###
  q = GLOBvar$q
  #nbVarMax = GLOBvar$nbVarMax
  smax = GLOBvar$smax
  xlocs = GLOBvar$xlocs
### end assignement ###
  
### assignement of hyperparameters variables used here ###
  c = HYPERvar$c
  alphalbd = HYPERvar$alphalbd
  betalbd = HYPERvar$betalbd
  alphad2 = HYPERvar$alphad2
  betad2 = HYPERvar$betad2
  v0 = HYPERvar$v0
  gamma0 = HYPERvar$gamma0
  ### end assignement ###

  if(DEBUGLVL2) { cat("\n -- START PHASE.UPDATE --\n\n") }

  if(DEBUGLVL2) { cat("S2Dall: "); print.table(S2Dall) }

  ## current number of edges
  s = length(S2Dall) - 2

  ## expected nr of edges (mean)
  Lambda = rgamma(1, shape=s + alphalbd, rate=1 + betalbd)
  
  ## Compute acceptation probability vector rho
  rho3 = computeRho3(s, 0, smax, c, Lambda)
  
  ## Sample u
  u = runif(1, 0, 1)
  
  ## Compute the corresponding move (Edge birth, Edge death or Update the regression coefficient) 
  bduout = bdu.homogeneousStructure(u, rho3, X, Y, XE, YE, Sall, Sig2all, q, v0, gamma0, smax, GLOBvar, HYPERvar)
  
  ##  Return all variables
  ## (+ variable move describing the move type  (1= CP birth, 2= CP death, 3= CP shift, 4= Update segments)
  return( list( S2Dall=S2Dall, B2Dall=B2Dall, Sig2_2Dall=Sig2_2Dall, move=4, accept=0, move1=bduout$move, accept1=bduout$accept))

}


bdu.homogeneousStructure <- function(u, rho3,X, Y, XE, YE, Sall, Sig2all, q, v0, gamma0, smax, GLOBvar, HYPERvar){

  ### INPUT:u,rho,s=S[i,],sig2=Sig2[i],delta2.
  ###	x: the data in state i in columns 
  ###	ni: total nb of repeated measurements	
  ### OUTPUT: newS,newSig2,newB.
  ### depends on: 
  ### q the number of predictors
  ### constant v0, gamma0.
  
  
  XMphase = GLOBvar$XMphase
  YMphase = GLOBvar$YMphase

  nbVarMax = GLOBvar$nbVarMax
  delta2 = HYPERvar$delta2
	
  ## Variable move describing the move type  (1= Edge birth, 2= Edge death, 3= Update coefficient, default=3)
  move = 3

  ## Boolean indicating whether the move is accepted or not (=1 if accepted, 0 otherwise, default=0)
  accept = 0

  ## New edges vector, to be returned at the end of the function
  S    = S2Dall
  newS = S   
  ## Current number of edges
  l = sum(S) - 1 # = L[i]
  
  # Choose between flip move and other moves
  choice = runif(1, 0, 1)
  
  # Flip Move
if(F) {
  ## if(l > 0 && choice > 0.75) {    
  ## flip move is 4
    move = 4
    
    ## Sample the original parent
    parent.orig = sample(c(which(S[1:q]==1), which(S[1:q]==1)),1) # needed when there is only one position  S[1:q]==1
    # Sample the new parent
    parent.new = sample(c(which(S==0), which(S==0)), 1) # needed when there is only one position  S==0
    
    stmp = S
    stmp[parent.orig] = 0
    stmp[parent.new]  = 1
    
    rflip = 1
    
    for(phase in E[1:(s+1)]) {
      ## Position of the phase
      posPhase = which(E==phase)
    
      ## Observations in the chosen phase
      y = Y[ Mphase[phase]:(Mphase[E[posPhase+1]]-1) ]
      x = X[ Mphase[phase]:(Mphase[E[posPhase+1]]-1), ]
    
      ## To update Sig2: matPx= Pxl, Pxlp1, or Pxlm1 depending the computed move (birth, death or update).
      ## Compute the projection matrix with the current edge ("Pxl")
      Pxl = computePx(length(y), x[,which(S == 1)], delta2)
    
      ## Compute the projection matrix with an additional edge ("Pxl plus 1")
      Pxlp1 = computePx(length(y), x[,which(stmp == 1)], delta2)
      
      rflip = rflip * ((gamma0 + t(y) %*% Pxlp1 %*% y)/(gamma0 + t(y) %*% Pxl %*% y))^(-(length(y) + v0)/2)
    }
    
    u = runif(1,0,1)
    
    if(u <= min(1,rflip)) {
      accept = 1
      newS = stmp
      Sall= t(matrix(newS,q+1, s+1)) 
    }
    
  } else {  
    ##########################
    ## Birth of an edge move
    ##########################
    if(u < rho3[1] && l < smax){
 
    ## Variable move describing the move type  (1= Edge birth, 2= Edge death, 3= Update coefficient)
    move = 1
    
    ## Sample the additional edge
    sstar = sample(c(which(S==0), which(S==0)), 1) # needed when there is only one position  S==0

    ## Proposed edges vector (with an additional edge)
    stmp = S
    stmp[sstar] = 1
 
    # updated by Sophie for Homogeneous Structure : sum over the posterior ratios
	  #### HERE : rbirth =1 (not 0)
	  rbirth =1
	  ## For each current phase
	  for (phase in E[1:(s+1)]){
    
      ## Position of the phase
      posPhase = which(E==phase)
    
      ## Observations in the chosen phase
      y = Y[ Mphase[phase]:(Mphase[E[posPhase+1]]-1) ]
      x = X[ Mphase[phase]:(Mphase[E[posPhase+1]]-1), ]
    
      ## To update Sig2: matPx= Pxl, Pxlp1, or Pxlm1 depending the computed move (birth, death or update).
      ## Compute the projection matrix with the current edge ("Pxl")
      Pxl = computePx(length(y), x[,which(S == 1)], delta2)
    
      ## Compute the projection matrix with an additional edge ("Pxl plus 1")
      Pxlp1 = computePx(length(y), x[,which(stmp == 1)], delta2)
    
      ## Compute birth ratio
	  ## HERE : * (not +)
      rbirth = rbirth * ((gamma0 + t(y) %*% Pxlp1 %*% y)/(gamma0 + t(y) %*% Pxl %*% y))^(-(length(y) + v0)/2)/sqrt(1 + delta2)
    
	  } # end for (phase in E[1:(s+1)]){
      
	  ## Sample u 
      u = runif(1,0,1)
    
    
      if(u <= min(1,rbirth)){
        accept = 1
        newS = stmp
	    Sall= t(matrix(newS,q+1, s+1)) 
	   # 		print(newS)
	  #	print(Sall)
      }
      
      ## at this stage : 
      ## newS=S if birth rejected
      ##    =stmp if birth accepted
	  
     } else {
      if(u < rho3[2]){
	  #print("removing an edge??")
	    ##########################
	    ## Death of an edge move
        ##########################
        ## Variable describing the move type  (1 for Edge birth, 2 for Edge death, 3 for Update coefficient)
        move=2
        
        ## Sample the edge to remove
        sstar = sample(c(which(S[1:q]==1), which(S[1:q]==1)),1) # needed when there is only one position  S[1:q]==1
        ## Proposed edges vector (after taking away one edge)
        stmp = S
        stmp[sstar] = 0
        
	    # updated by Sophie for Homogeneous Structure : sum over the posterior ratios
	    rdeath =1
	    ## For each current phase
	    for (phase in E[1:(s+1)]){
    
        ## Position of the phase
        posPhase = which(E==phase)
    
        ## Observations in the chosen phase
        y = Y[ Mphase[phase]:(Mphase[E[posPhase+1]]-1) ]
        x = X[ Mphase[phase]:(Mphase[E[posPhase+1]]-1), ]
    
        ## To update Sig2: matPx= Pxl, Pxlp1, or Pxlm1 depending the computed move (birth, death or update).
        ## Compute the projection matrix with the current edge ("Pxl")
        Pxl = computePx(length(y), x[,which(S == 1)], delta2)
    
        ## Compute the projection matrix after removimg one edge ("Pxl minus 1")
        Pxlm1 = computePx(length(y), x[,which(stmp==1)], delta2)
    
        ## Compute death ratio
        rdeath= rdeath*((gamma0 + t(y) %*% Pxl %*% y)/(gamma0 + t(y) %*% Pxlm1 %*% y))^((length(y) + v0)/2)*(sqrt(1 + delta2))
	    } # end for (phase in E[1:(s+1)])
	    
        ## Sample u 
        u<-runif(1,0,1)
         #print(u)
	     #print(rdeath)  
	  
        if(u <= min(1,rdeath)){
          ## Boolean for the acceptation of the CP death move (=1 if birth accepted, 0 otherwise)
          accept = 1
          newS = stmp
	  	Sall= t(matrix(newS,q+1, s+1)) 
	  	#print(newS)
	  	#print(Sall)
         }
      } # end if  if(u < rho3[2]){
    } # end else if(u < rho3[1] && l < smax){
    }
    	 
  ## Updating coefficients 
  Ball=matrix(0, s+1, q+1)
  newB = array(0, q+1)
  
  ## Moved below by Sophie 03/09/2010
  ## if(sum(newS) > 0){
    
  ## For each current phase
  for (phase in E[1:(s+1)]){
  
      ## Position of the phase
      posPhase = which(E==phase)

      ## Observations in the chosen phase
      y = Y[ Mphase[phase]:(Mphase[E[posPhase+1]]-1) ]
      x = X[ Mphase[phase]:(Mphase[E[posPhase+1]]-1), ]
	
      if(nbVarMax >1){
        Sig2 = Sig2all[posPhase]
      } else {
        Sig2 = Sig2all
      }
	
      ## 'if(sum(newS) > 0){' Added by Sophie 03/09/2010 
      if(sum(newS) > 0){
         # sample newB
         newB[which(newS == 1)] = sampleBxy(x[, which(newS==1)], y, Sig2, delta2)
         Ball[posPhase, ] = as.matrix(newB)
      } # end   if(sum(newS) > 0)
	  
      ## Added by Sophie 03/09/2010
      Sig2all[posPhase] = updateSigMulti(phase, X, Y, E, Sall, Ball, Sig2, Mphase, HYPERvar$alphad2, HYPERvar$betad2, HYPERvar$v0, HYPERvar$gamma0)
  
   } # end for (phase in E[1:(s+1)]){
 
  ##} # end   if(sum(newS) > 0){
  
  ##  Return all variables
  return(list( newS=newS, newB=newB, u=u, move=move, accept=accept, Ball=Ball, Sall=Sall, Sig2all=Sig2all)) 
}










bdu <- function(u, rho3, x, y, S, Sig2, delta2, q, v0, gamma0, qmax, DEBUGLVL1 = F){

  ### INPUT:u,rho,s=S[i,],sig2=Sig2[i],delta2.
  ###	x:  the predictor values in each timesport in this phase (it was called for)
  ###   y : the target values in each timespot of this phase
  ###	ni: total nb of repeated measurements	
  ### OUTPUT: newS,newSig2,newB.
  ### depends on: 
  ### q the number of predictors (when sampling a new structure from the old)
  ### constant v0, gamma0.

  ## Variable move describing the move type  (1= Edge birth, 2= Edge death, 3= Update coefficient, default=3)
  move = 3

  ## Boolean indicating whether the move is accepted or not (=1 if accepted, 0 otherwise, default=0)
  accept = 0

  ## New edges vector, to be returned at the end of the function
  newS = S

  ## To update Sig2: matPx= Pxl, Pxlp1, or Pxlm1 depending the computed move (birth, death or update).
  ## Compute the projection matrix with the current edge ("Pxl")
  Pxl = computePx(length(y), x[,which(S == 1)], delta2)
  
  ## Current number of edges
  l = sum(S) - 1 # = L[i]

  # Choose between flip move and other moves
  choice = runif(1, 0, 1)
  
  # Flip Move
  if(l > 0 && choice > 0.75) {    
    # flip move is 4
    move = 4
    
    ## Sample the original parent
    parent.orig = sample(c(which(S[1:q]==1), which(S[1:q]==1)),1) # needed when there is only one position  S[1:q]==1
    # Sample the new parent
    parent.new = sample(c(which(S==0), which(S==0)), 1) # needed when there is only one position  S==0

    stmp = S
    stmp[parent.orig] = 0
    stmp[parent.new]  = 1

    ## Compute the projection matrix with flipped edges
    Pxlp1 = computePx(length(y), x[,which(stmp == 1)], delta2)
      
    rflip = ((gamma0 + t(y) %*% Pxlp1 %*% y)/(gamma0 + t(y) %*% Pxl %*% y))^(-(length(y) + v0)/2)
       
    u = runif(1,0,1)
    
    if(u <= min(1,rflip)) {
      if(DEBUGLVL1) { cat("f") }
      accept = 1
      newS = stmp

    } 
    
  } else {

    
    if(u < rho3[1] && l < qmax){
      ## Variable move describing the move type  (1= Edge birth, 2= Edge death, 3= Update coefficient)
      move = 1

      ## Sample the additional edge
      sstar = sample(c(which(S==0), which(S==0)), 1) # needed when there is only one position  S==0

      ## Proposed edges vector (with an additional edge)
      stmp = S
      stmp[sstar] = 1
    
      ## Compute the projection matrix with an additional edge ("Pxl plus 1")
      Pxlp1 = computePx(length(y), x[,which(stmp == 1)], delta2)

      ## Compute birth ratio
      rbirth = ((gamma0 + t(y) %*% Pxlp1 %*% y)/(gamma0 + t(y) %*% Pxl %*% y))^(-(length(y) + v0)/2)/sqrt(1 + delta2)

      ## Sample u 
      u = runif(1,0,1)
                                     
      if(u <= min(1,rbirth)){
        if(DEBUGLVL1) { cat("e") }
        accept = 1
        newS = stmp
      }
        
    } else {
      if(u < rho3[2]){
        ## Variable describing the move type  (1 for Edge birth, 2 for Edge death, 3 for Update coefficient)
        move=2
        
        ## Sample the added predictor
        sstar = sample(c(which(S[1:q]==1), which(S[1:q]==1)),1) # needed when there is only one position  S[1:q]==1
        ## Proposed edges vector (after taking away one edge)
        stmp = S
        stmp[sstar] = 0
        
        ## Compute the projection matrix after removimg one edge ("Pxl minus 1")
        Pxlm1 = computePx(length(y), x[,which(stmp==1)], delta2)
        
        ## Compute death ratio
        rdeath=((gamma0 + t(y) %*% Pxl %*% y)/(gamma0 + t(y) %*% Pxlm1 %*% y))^((length(y) + v0)/2)*(sqrt(1 + delta2))
        
        ## Sample u 
        u<-runif(1,0,1)
        
        if(u <= min(1,rdeath)){
          if(DEBUGLVL1) { cat("t") }

          ## Boolean for the acceptation of the CP death move (=1 if birth accepted, 0 otherwise)
          accept = 1
          newS = stmp
        }
      }
    }
  }
  
  ## Updating coefficients 
  newB = array(0, q+1)
  if(sum(newS) > 0){
    newB[which(newS == 1)] = sampleBxy(x[, which(newS==1)], y, Sig2, delta2)
  }
 
  ##  Return all variables
  return(list( newS=newS, newB=newB, u=u, move=move, accept=accept))
}








